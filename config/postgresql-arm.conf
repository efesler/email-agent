# PostgreSQL Configuration optimisée pour Oracle ARM Free Tier
# 24 GB RAM, 4 OCPUs ARM Ampere A1
# Usage: Monté dans le conteneur PostgreSQL

# ==============================================
# MEMORY SETTINGS (optimisé pour 24GB système)
# ==============================================

# Mémoire partagée pour cache PostgreSQL
shared_buffers = 2GB                # 1/12 de la RAM totale

# Mémoire pour planification de requêtes
effective_cache_size = 6GB          # 1/4 de la RAM totale

# Mémoire pour opérations de maintenance (CREATE INDEX, VACUUM)
maintenance_work_mem = 512MB

# Mémoire pour opérations de tri et jointures (par connexion)
work_mem = 64MB                     # 512MB / 8 connexions max

# ==============================================
# CHECKPOINTS & WAL
# ==============================================

# Taille minimale des WAL avant checkpoint
min_wal_size = 1GB

# Taille maximale des WAL
max_wal_size = 4GB

# Progression du checkpoint (évite pics I/O)
checkpoint_completion_target = 0.9

# Buffer pour WAL
wal_buffers = 16MB

# ==============================================
# QUERY PLANNER
# ==============================================

# Coût relatif d'accès aléatoire (SSD = 1.1)
random_page_cost = 1.1

# Échantillonnage pour statistiques
default_statistics_target = 100

# I/O concurrent effectif (ARM = bonne parallélisation)
effective_io_concurrency = 200

# ==============================================
# PARALLELISM (optimisé pour 4 cores ARM)
# ==============================================

# Workers max pour opérations parallèles
max_worker_processes = 4

# Workers max par requête parallèle
max_parallel_workers_per_gather = 2

# Workers parallèles totaux
max_parallel_workers = 4

# ==============================================
# CONNECTION & RESOURCE USAGE
# ==============================================

# Connexions max (API + Workers + Admin)
max_connections = 50

# ==============================================
# LOGGING (production)
# ==============================================

# Niveau de log
log_min_duration_statement = 1000   # Log requêtes > 1 sec

# Rotation des logs
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d.log'
log_rotation_age = 1d
log_rotation_size = 100MB

# Checkpoints dans les logs
log_checkpoints = on

# Connexions dans les logs
log_connections = on
log_disconnections = on

# ==============================================
# AUTOVACUUM (important pour performance longue durée)
# ==============================================

autovacuum = on
autovacuum_max_workers = 2
autovacuum_naptime = 30s

# ==============================================
# LOCALE & TIMEZONE
# ==============================================

lc_messages = 'en_US.UTF-8'
lc_monetary = 'en_US.UTF-8'
lc_numeric = 'en_US.UTF-8'
lc_time = 'en_US.UTF-8'
timezone = 'UTC'

# ==============================================
# ARM-SPECIFIC OPTIMIZATIONS
# ==============================================

# Utiliser bytea_output en hex pour compatibilité ARM
bytea_output = 'hex'

# Optimisations pour processeurs ARM
cpu_tuple_cost = 0.01
cpu_index_tuple_cost = 0.005
cpu_operator_cost = 0.0025

# ==============================================
# NOTES DE PERFORMANCE
# ==============================================

# Configuration testée pour :
# - 20 000+ emails
# - 4 workers Celery simultanés
# - Classification LLM intensive
# - Synchronisation multi-comptes

# Métriques attendues :
# - 200-500 TPS (transactions/sec)
# - Latence moyenne < 50ms
# - Cache hit ratio > 95%
